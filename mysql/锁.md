# MySql 锁
MySQL 锁分为：表锁、行锁、页锁和元数据锁。表锁：当访问表并且该表所使用的存储引擎支持表锁的时候，即会产生表锁，如 MYISAM，
或者在存储引擎上使用：LOCK TABLE；
元数据锁：为了解决线程可以在其他线程中的并发事务使用相同表的情况下修改表的定义或者删除表的问题。<br/>


说明	      隔离级别	        脏读	     不可重复读	幻读  	加锁
未提交读	READ UNCOMMITTED	YES	     YES	    YES 	NO
提交读	READ COMMITTED	    NO	     YES	    YES 	NO
重复读	REPEATABLE READ	    NO	     NO	        YES 	NO
串行读	SERIALIZABLE	    NO	     NO	        NO	    YES

> 如何尽可能避免死锁
1）以固定的顺序访问表和行。比如对第2节两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；又比如对于3.1节的情形，将两个事务的sql顺序调整为一致，也能避免死锁。<br/>
2）大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。<br/>
3）在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。<br/>
4）降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。<br/>
5）为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。<br/>

> 如何定位死锁成因
1）通过应用业务日志定位到问题代码，找到相应的事务对应的sql<br/>
2）确定数据库隔离级别。
   执行select @@global.tx_isolation，可以确定数据库的隔离级别，我们数据库的隔离级别是RC，这样可以很大概率排除gap锁造成死锁的嫌疑;<br/>
3）找DBA执行下show InnoDB STATUS看看最近死锁的日志。<br/>

